#include "tsetwlog.h"
#include <vector>

// GUID generated by https://blogs.msdn.microsoft.com/dcook/2015/09/08/etw-provider-names-and-guids/
TRACELOGGING_DEFINE_PROVIDER(
	g_hMyProvider,
	"tsserverEventSource",
	// {ac4e9dd1-3a7a-5022-fc37-f2394bc4f09e}
	(0xac4e9dd1, 0x3a7a, 0x5022, 0xfc, 0x37, 0xf2, 0x39, 0x4b, 0xc4, 0xf0, 0x9e));

namespace demo {
	constexpr size_t STRING_ARG_BUFFER_SIZE = 1024;

	TraceLoggingThreadActivity<g_hMyProvider> *cmdActivity = nullptr;
	TraceLoggingThreadActivity<g_hMyProvider> *programActivity = nullptr;
	TraceLoggingThreadActivity<g_hMyProvider> *resolveModuleActivity = nullptr;
	TraceLoggingThreadActivity<g_hMyProvider> *readFileActivity = nullptr;
	TraceLoggingThreadActivity<g_hMyProvider> *parseActivity = nullptr;
	TraceLoggingThreadActivity<g_hMyProvider> *bindActivity = nullptr;
	TraceLoggingThreadActivity<g_hMyProvider> *scheduledActivity = nullptr;
	std::vector<TraceLoggingThreadActivity<g_hMyProvider> *> updateGraphActivityList{};

	void InitEtw() {
		TraceLoggingRegister(g_hMyProvider);
	}

	void CleanupEtw(void *arg)
	{
		TraceLoggingUnregister(g_hMyProvider);
	}

	bool GetStringsFromArgs(napi_env env, napi_callback_info cb_info, size_t count, wchar_t* pArg1, wchar_t* pArg2)
	{
		napi_status status;
		size_t argCount = count;
		napi_value thisArg;
		void *pData;
		napi_valuetype valueType;
		size_t written;

		// Note: Increase these values and update conditions below to support more than 2 string args
		// (And if more than 2, should probably convert into an indexed loop and pass string pointers as an array)
		napi_value result[2];
		if (count > 2) return false; // Only supports up to two args currently

		status = napi_get_cb_info(env, cb_info, &argCount, result, &thisArg, &pData);
		if (status != napi_ok || argCount < count) return false;

		status = napi_typeof(env, result[0], &valueType);
		if (status != napi_ok || valueType != napi_valuetype::napi_string) return false;
		if (count >= 2)
		{
			status = napi_typeof(env, result[1], &valueType);
			if (status != napi_ok || valueType != napi_valuetype::napi_string) return false;
		}

		status = napi_get_value_string_utf16(env, result[0], (char16_t*)pArg1, STRING_ARG_BUFFER_SIZE, &written);
		if (status != napi_ok) return false;
		if (count >= 2)
		{
			status = napi_get_value_string_utf16(env, result[1], (char16_t*)pArg2, STRING_ARG_BUFFER_SIZE, &written);
			if (status != napi_ok) return false;
		}

		return true;
	}

	void LogActivityError(wchar_t *pMsg) {
		TraceLoggingWrite(g_hMyProvider, 
			"ActivityError", 
			TraceLoggingLevel(WINEVENT_LEVEL_ERROR),
			TraceLoggingWideString(pMsg, "msg"));
	}

	napi_value LogEvent(napi_env env, napi_callback_info args) {
		if (!TraceLoggingProviderEnabled(g_hMyProvider, /* any level */0, /* any keywords */0))
		{
			return nullptr;
		}

		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!GetStringsFromArgs(env, args, 1, pMsg, nullptr)) return nullptr;

		TraceLoggingWrite(g_hMyProvider,
			"Message",
			TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE), // Level is optional
			//TraceLoggingKeyword(0x10),               // Keywords are optional
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}

	napi_value LogErrEvent(napi_env env, napi_callback_info args) {
		if (!TraceLoggingProviderEnabled(g_hMyProvider, /* any level */0, /* any keywords */0))
		{
			return nullptr;
		}

		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!GetStringsFromArgs(env, args, 1, pMsg, nullptr)) return nullptr;

		TraceLoggingWrite(g_hMyProvider,
			"Err",
			TraceLoggingLevel(WINEVENT_LEVEL_ERROR),
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}

	napi_value LogInfoEvent(napi_env env, napi_callback_info args) {
		if (!TraceLoggingProviderEnabled(g_hMyProvider, WINEVENT_LEVEL_VERBOSE, /* any keywords */0))
		{
			return nullptr;
		}

		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!GetStringsFromArgs(env, args, 1, pMsg, nullptr)) return nullptr;

		TraceLoggingWrite(g_hMyProvider,
			"Info",
			TraceLoggingLevel(WINEVENT_LEVEL_VERBOSE),
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}

	napi_value LogPerfEvent(napi_env env, napi_callback_info args) {
		if (!TraceLoggingProviderEnabled(g_hMyProvider, /* any level */0, /* any keywords */0))
		{
			return nullptr;
		}

		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!GetStringsFromArgs(env, args, 1, pMsg, nullptr)) return nullptr;

		TraceLoggingWrite(g_hMyProvider,
			"Perf",
			TraceLoggingKeyword(TSSERVER_KEYWORD_PERF),
			TraceLoggingWideString(pMsg, "msg")
		);
		
		return nullptr;
	}

	napi_value LogStartCommand(napi_env env, napi_callback_info args) {
		if (cmdActivity != nullptr) {
			LogActivityError(L"StartCommand called with existing activity");
			return nullptr;
		}

		wchar_t pCmd[STRING_ARG_BUFFER_SIZE];
		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!GetStringsFromArgs(env, args, 2, pCmd, pMsg)) return nullptr;

		cmdActivity = new TraceLoggingThreadActivity<g_hMyProvider>();

		TraceLoggingWriteStart(*cmdActivity, "Command",
			TraceLoggingWideString(pCmd, "command"),
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}

	napi_value LogStopCommand(napi_env env, napi_callback_info args) {
		if (cmdActivity == nullptr) {
			LogActivityError(L"StopCommand called with no existing activity");
			return nullptr;
		}

		wchar_t pCmd[STRING_ARG_BUFFER_SIZE];
		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!GetStringsFromArgs(env, args, 2, pCmd, pMsg)) return nullptr;

		TraceLoggingWriteStop(*cmdActivity, "Command",
			TraceLoggingWideString(pCmd, "command"),
			TraceLoggingWideString(pMsg, "msg")
		);

		delete cmdActivity;
		cmdActivity = nullptr;
		return nullptr;
	}

	bool StartActivityHelper(napi_env env, napi_callback_info args, TraceLoggingThreadActivity<g_hMyProvider> *&activity, wchar_t *pMsg) {
		if (activity != nullptr) {
			LogActivityError(L"StartActivityHelper called with active activity");
			return false;
		}

		activity = new TraceLoggingThreadActivity<g_hMyProvider>();

		if (!GetStringsFromArgs(env, args, 1, pMsg, nullptr)) return false;

		return true;
	}

	napi_value LogStartUpdateProgram(napi_env env, napi_callback_info args) {
		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!StartActivityHelper(env, args, programActivity, pMsg)) return nullptr;

		TraceLoggingWriteStart(*programActivity, "UpdateProgram",
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}

	napi_value LogStopUpdateProgram(napi_env env, napi_callback_info args) {
		if (programActivity == nullptr) {
			LogActivityError(L"StopUpdateProgram called with no existing activity");
			return nullptr;
		}

		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!GetStringsFromArgs(env, args, 1, pMsg, nullptr)) return nullptr;

		TraceLoggingWriteStop(*programActivity, "UpdateProgram",
			TraceLoggingWideString(pMsg, "msg")
		);

		delete programActivity;
		programActivity = nullptr;
		return nullptr;
	}

	napi_value LogStartUpdateGraph(napi_env env, napi_callback_info args) {
		// UpdateGraph is reentrant. So always maintain a list of activities for these calls.
		auto newActivity = new TraceLoggingThreadActivity<g_hMyProvider>();
		updateGraphActivityList.push_back(newActivity);

		TraceLoggingWriteStart(*newActivity, "UpdateGraph");

		return nullptr;
	}
	napi_value LogStopUpdateGraph(napi_env env, napi_callback_info args) {
		// Below could happen if logging was enabled in the midst of an activity
		if (updateGraphActivityList.size() <= 0) {
			LogActivityError(L"StopUpdateGraph called with no active activity");
			return nullptr;
		}
		
		TraceLoggingWriteStop(*(updateGraphActivityList.back()), "UpdateGraph");
		updateGraphActivityList.pop_back();

		return nullptr;
	}

	napi_value LogStartResolveModule(napi_env env, napi_callback_info args) {
		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!StartActivityHelper(env, args, resolveModuleActivity, pMsg)) return nullptr;

		TraceLoggingWriteStart(*resolveModuleActivity, "ResolveModule",
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}

	napi_value LogStopResolveModule(napi_env env, napi_callback_info args) {
		if (resolveModuleActivity == nullptr) {
			LogActivityError(L"StopResolveModule called with no existing activity");
			return nullptr;
		}

		wchar_t pSuccess[STRING_ARG_BUFFER_SIZE];
		GetStringsFromArgs(env, args, 1, pSuccess, nullptr);

		TraceLoggingWriteStop(*resolveModuleActivity, "ResolveModule", TraceLoggingWideString(pSuccess, "msg"));
		delete resolveModuleActivity;
		resolveModuleActivity = nullptr;
		return nullptr;
	}

	napi_value LogStartParseSourceFile(napi_env env, napi_callback_info args) {
		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!StartActivityHelper(env, args, parseActivity, pMsg)) return nullptr;

		TraceLoggingWriteStart(*parseActivity, "ParseSourceFile",
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}

	napi_value LogStopParseSourceFile(napi_env env, napi_callback_info args) {
		if (parseActivity == nullptr) {
			LogActivityError(L"StopParseSourceFile called with no existing activity");
			return nullptr;
		}

		TraceLoggingWriteStop(*parseActivity, "ParseSourceFile");
		delete parseActivity;
		parseActivity = nullptr;
		return nullptr;
	}
	napi_value LogStartReadFile(napi_env env, napi_callback_info args) {
		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!StartActivityHelper(env, args, readFileActivity, pMsg)) return nullptr;

		TraceLoggingWriteStart(*readFileActivity, "ReadFile",
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}

	napi_value LogStopReadFile(napi_env env, napi_callback_info args) {
		if (readFileActivity == nullptr) {
			LogActivityError(L"StopReadFile called with no existing activity");
			return nullptr;
		}

		TraceLoggingWriteStop(*readFileActivity, "ReadFile");
		delete readFileActivity;
		readFileActivity = nullptr;
		return nullptr;
	}
	napi_value LogStartBindFile(napi_env env, napi_callback_info args) {
		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!StartActivityHelper(env, args, bindActivity, pMsg)) return nullptr;

		TraceLoggingWriteStart(*bindActivity, "BindFile",
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}

	napi_value LogStopBindFile(napi_env env, napi_callback_info args) {
		if (bindActivity == nullptr) {
			LogActivityError(L"StopBindFile called with no existing activity");
			return nullptr;
		}

		TraceLoggingWriteStop(*bindActivity, "BindFile");
		delete bindActivity;
		bindActivity = nullptr;
		return nullptr;
	}

	napi_value LogStartScheduledOperation(napi_env env, napi_callback_info args) {
		wchar_t pMsg[STRING_ARG_BUFFER_SIZE];
		if (!StartActivityHelper(env, args, scheduledActivity, pMsg)) return nullptr;

		TraceLoggingWriteStart(*scheduledActivity, "ScheduledOperation",
			TraceLoggingWideString(pMsg, "msg")
		);

		return nullptr;
	}
	napi_value LogStopScheduledOperation(napi_env env, napi_callback_info args) {
		if (scheduledActivity == nullptr) {
			LogActivityError(L"StopScheduledOperation called with no existing activity");
			return nullptr;
		}

		TraceLoggingWriteStop(*scheduledActivity, "ScheduledOperation");
		delete scheduledActivity;
		scheduledActivity = nullptr;
		return nullptr;
	}

}
